# 手写深拷贝
众所周知，对于`数组`拷贝过程中总是难免遇到`嵌套`对象的问题，可能是`数组`嵌套，也可能是`对象`嵌套，又由于`JS`的变量属性分为了`基本数据类型`和`引用数据类型`，`基本数据类型`因为都是保存在栈中，在拷贝操作的时候会另外开辟一个新的栈空间，没有问题，但是`引用数据类型`可是个"刺头"，首先`引用数据类型`的指针保存在栈中，而实际的内容保存在堆中，这就导致我们浅拷贝的时候拷贝的是指针，这样会导致新旧指针指向同一个堆，这么做会导致什么问题呢？那就是新旧对象的操作都会影响到数据，这明显不符合我们拷贝的想法，因此对于`深拷贝`的需求应运而生。  
## 浅拷贝
本着`知其然知其所以然`的态度，我们先来了解一下`浅拷贝的几种方式`:
- `Array.concat()`
- `Array.slice()`

上述两种方法都是比较经典的数组`浅拷贝`方式，但是我们也说了，浅拷贝存在无法拷贝`引用数据类型`的问题，接下来让我们看看比较常见的`深拷贝`方式  
## 深拷贝
常见的`深拷贝`有以下几种方式:
- `JSON.stringfy()`
- lodsh的`_deepClone()`
- 手写深拷贝
### JSON.stringfy()
首先是`JSON.stringfy()`，这是一个简单粗暴的方法，不仅能深拷贝对象和数组，而且人家还很简单！
```
let arr = ['old', 1, true, ['old', 'old2'], { old: 1 }];
let newArr = JSON.parse(JSON.stringify(arr));
```
就是这么简单，就完成了`深拷贝`，你看，多爽，不过没那么简单，由于`JSON.stringfy()`的特性，他无法拷贝函数，这是为啥？因为`JSON.stringfy()`的特性就是在遇到`null`、`undefined`、`function`类型时自动忽略，自然也就无法完成函数的拷贝啦
### _deepClone()
我们可以借助现有的js库函数完成深拷贝，因为我自己也没用过，所以就不献丑了
### 手写深拷贝
来到我们今天的重头戏，手写深拷贝，这也是经典的面试题了，虽然我现在就没几个面试，但是本着今天不是你卷死我就是我卷死你的态度，我们来一起手写看看：  
首先我们要明确深拷贝的要点：
- 遇到嵌套我们应该怎么办？遇到嵌套那么我们应该想到`递归`
- 遇到循环引用怎么办？也就是`a`中有`b`，`b`中有`a`，平常手写深拷贝的时候老是会忽略这个问题，但是这次正义的我不能坐视不管，我们用Map()来进行记录，如果出现循环引用，那么直接返回即可，不然可就陷入嵌套之中了

ok，整体方向就这两个问题，接下来就看代码，具体细节显示在注释中
```
function deepClone(source, map = new Map()) {
  // 根据是数组还是对象初始化
  let target = Array.isArray(source) ? [] : {};
  // 如果存在循环引用则直接返回
  if(map.has(source)) return map.get(source);
  map.set(source, target);

  // 遍历循环source中的属性，也就是要拷贝的对象
  for(const key in source) {
    // 必须是source自身拥有的属性，不能是原型链脸上的属性
    if(source.hasOwnProperty(key)) {
      // 如果是嵌套对象则递归执行
      // 否则直接拷贝即可
      target[key] = typeof source[key] === 'object' ? deepClone(source[key], map) : source[key];
    }
  }
  return target;
}
```
怎么样，是不是看起来还可以？个人感觉完美