# 手写柯里化
说到`柯里化`，我们不得不提的是目前流行的框架`React`，它提倡的就是`函数式编程`，它是一种`编程范式`，目前主要的编程范式有三种: `命令式编程`、`声明式编程`以及`函数式编程`，`Vue`用的是`声明式编程`，`React`用的是`函数式编程`，除了`命令式编程`，其他两种编程范式更加强调结果，让用户专注于方式的使用而不是过程；`函数式编程`提倡利用若干个简单的执行单元渐进式的完成一个复杂的运算或者组件；简单的说，就是将过程逻辑写成函数，只关心他的输出结果。
## 纯函数
`函数式编程`旨在尽可能的提高代码的`无状态性`和`不变性`，比较我想要通过多个函数组合希望函数是不变的，不然多次组合导致不同的结果这会导致意想不到的结果，而我们想要的这种无副作用的函数，就是`纯函数`  
`纯函数`是对给定的输入返还相同输出的函数，并且要求你所有的数据都是不变的，即`纯函数` = `无状态` + `数据不可变`  
### 特性
- 函数内部传入指定的值，就会返回确定唯一的值
- 不会造成超出作用域的变化，例如修改全局变量或引用传递的参数
### 优势
- 因为纯函数是无状态的，所以可以产生可测试的代码
- 不依赖外部环境变化，不会产生副作用，提高函数的复用性
- 可读性更强，函数都会有一个语义化的名称
- 可以组成复杂任务的可能性。符合模块化概念及单一职责原则
## 高阶函数
`函数式编程`要组合纯函数，所以组合而成的函数可以就是一种`高阶函数`  
`高阶函数` ：以函数作为输入或输出的函数叫做`高阶函数` ，通过`高阶函数` 抽象过程，用户能够只关注结果
### 柯里化
前面铺垫了这么久，我们的主角终于要出来了，`柯里化`就是能将一个多参数函数转换成一个嵌套的一元函数的过程，我们来实现一个多参数的`curry`函数：
```
function curry(fn) {
  return function curriedFn(...args) {
    if(fn.length > args.length) {
      return function() {
        return curriedFn(...args.concat(...arguments));
      }
    }
    return fn(...args);
  }
}

const fn = (x, y, z, a) => x + y + z + a;
const myFn = curry(fn);
console.log(myFn(1)(2)(3)(1)); // 7
```
`curry`函数本质上就是为了降低通用性，提高复用性，让纯函数更纯，每次只接收一个参数，解散解耦，惰性执行