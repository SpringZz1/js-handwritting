# 手写m的n次方
吓人吓人真吓人，看美团二面面经居然有面试官问怎么求m的n次方怎么求，什么？！这也难？别说，如果不限制你时间复杂度那怎么样都好，如果限制时间复杂度为`O(logn)`你该怎么做呢？我也是经过百度才知道咋做的，接下来我们先一步一步来看看具体是怎么做的：
## 最原始的解法
```
function pow(m, n) {
  return Math.pow(m, n);
}

console.log(pow(2, 10)); // 1024
```
这是最简单的，使用`Math.pow`我们就能很简单的达到这个效果，但是时间复杂度为`O(n)`，不符合要求，而且要是这么简单，面试官也不会问你了，所以我们来看看该如何优化这个问题呢？
## 第一次优化
既然我们要求m的n次方，那有没有办法加快求的速度呢？最原始的方法是通过`m * m * m`不断重复`n`次达到效果的，那么我们能不能通过`m^2`来减少这个过程呢？可以，只是我们需要注意n的奇偶情况，在n为奇数时，我们需要额外再乘以`m`：
```
function pow(m, n) {
  let res = 1;
  let temp = m * m;
  let index = Math.floor(n / 2);
  for(let i = 0; i < index; i++) {
    res *= temp;
  }
  if(n % 2 !== 0) {
    res *= m;
  }
  return res;
}

console.log(pow(2, 10)); // 1024
```
这样时间复杂度在奇数字情况下减少到了`O(n / 2 - 1)`，偶数情况下为`O(n / 2)`。  
但是还是不行阿，我们要求的是`O(logn)`,别急，答案就要出来了
## 最终优化
既然我们可以利用`m^2`来加速优化，那我们不如接着利用`m^2`,`m^4`,`m^8`这样加速下去，这样就达到了指数级别的加速，时间复杂度降低到`O(logn)`，不过还是一样，我们需要额外考虑指数n为奇数的情况，如果指数n为奇树，则当前值需要额外乘以一次`base`
```
function pow(m, n) {
  let res = 1;
  let base = m;
  while(n !== 0) {
    if(n % 2 !== 0) {
      res *= base;
    }
    base *= base;
    n = Math.floor(n / 2);
  }
  return res;
}

console.log(pow(2, 10)); // 1024
```
至此，我们的优化算法结束，这回面试官应该满意了吧？